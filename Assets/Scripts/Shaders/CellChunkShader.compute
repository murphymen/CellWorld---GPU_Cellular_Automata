#pragma kernel ClearData;
#pragma kernel OneStep;
#pragma kernel DrawChunk;
#pragma kernel SetCells;
#pragma kernel CopyInput;


#include "Cell.cginc"
#include "Directions.cginc"


uint _width;
uint _height;
uint _inputWidth;
uint _inputHeight;
RWTexture2D<float4> _mainBuffer;
RWStructuredBuffer<Cell> _chunkBuffer;
RWStructuredBuffer<uint> _inputBuffer;
bool _debug;
RWStructuredBuffer<uint> _debugBuffer;

bool CheckBottom(uint x, uint y)
{
    if (y == 0)
        return true;
    return _chunkBuffer[x + (y-1) * _width].type > 0;
}

void MoveBottom(uint x, uint y)
{
    if (y == 0)
        return;
    _chunkBuffer[x + (y-1) * _width].type = _chunkBuffer[x + y * _width].type;
    _chunkBuffer[x + y * _width].type = 0;
}

void SandBehavior(uint2 id)
{
    uint flatIndex = id.x + (id.y * _width);

    // if below this cell is empty, then move down
    if(!CheckBottom(id.x, id.y))
    {
       MoveBottom(id.x, id.y);
    }
    else
    {
       
    }

    _chunkBuffer[6].type = 666;
}

[numthreads(8, 8, 1)]
void ClearData (uint3 id : SV_DispatchThreadID)
{
    // Boundary check
    if(id.x >= _width || id.y >= _height)
        return;

    // Make flatIdex with y up to down
    uint flatIndex = id.x + (id.y * _width);
    
    _chunkBuffer[flatIndex].isActive = 0;
    _chunkBuffer[flatIndex].isMoved = 0;
    _chunkBuffer[flatIndex].value = 0;
    _chunkBuffer[flatIndex].type = 0;
}

[numthreads(8, 8, 1)]
void SetCells (uint3 id : SV_DispatchThreadID)
{
    //Boundary check
    if(id.x >= _width || id.y >= _height)
        return;

    for(uint j = 0; j < _inputHeight; j++)
    {
        for(uint i = 0; i < _inputWidth; i++)
        {
            uint flatIndex = i + (j * _inputWidth);
            _chunkBuffer[flatIndex].type = _inputBuffer[flatIndex];
            _chunkBuffer[flatIndex].isActive = 1;
            _chunkBuffer[flatIndex].isMoved = 0;
        }
    }

    // Debug
    if(_debug)
    {
        _chunkBuffer[3].type = 666;
    }
}

[numthreads(8,8,1)]
void CopyInput (uint3 id : SV_DispatchThreadID)
{
    // Boundary check
    if(id.x >= _width || id.y >= _height)
        return;

    uint flatIndex = id.x + (id.y * _inputWidth);
    _chunkBuffer[flatIndex].type = _inputBuffer[flatIndex];
    _chunkBuffer[flatIndex].isActive = 1;
    _chunkBuffer[flatIndex].isMoved = 0;

    
    _chunkBuffer[0].type = 666;
    /*
    switch(_chunkBuffer[flatIndex].type)
    {
        case 0:
            _mainBuffer[id.xy] = float4(0, 0, 0, 1);
            break;
        case 1:
            _mainBuffer[id.xy] = float4(.5, .5, .5, 1);
            break;
        case 666:
            _mainBuffer[id.xy] = float4(1, 0, 0, 1);
            break;
    }
    */
}

[numthreads(8,8,1)]
void OneStep (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _width || id.y >= _height)
        return;
    //if(_chunkBuffer[id.x + (id.y * _width)].isMoved == 1)
    //    return;
    uint flatIndex = id.x + (id.y * _width);

    _chunkBuffer[1].type = 666;

    switch(_chunkBuffer[flatIndex].type)
    {
        case 1:
            SandBehavior(uint2(id.x, id.y));
            break;
    }
}

[numthreads(8,8,1)]
void DrawChunk (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _width || id.y >= _height)
        return;

    uint flatIndex = id.x + (id.y * _width);

    _chunkBuffer[2].type = 666;
    switch(_chunkBuffer[flatIndex].type)
    {
        case 0:
            _mainBuffer[id.xy] = float4(0, 0, 0, 1);
            break;
        case 1:
            _mainBuffer[id.xy] = float4(.5, .5, .5, 1);
            break;
        case 666:
            _mainBuffer[id.xy] = float4(1, 0, 0, 1);
            break;
    }
    
}

