#pragma kernel ClearData;
#pragma kernel OneStep;
#pragma kernel DrawChunk;
#pragma kernel CopyInput;
#pragma kernel InsertCells;

#include "Assets/Scripts/Shaders/Types/Cell.cginc"
#include "Assets/Scripts/Shaders/Tools/Directions.cginc"
#include "Assets/Scripts/Shaders/Tools/Buffers.cginc"
#include "Assets/Scripts/Shaders/Tools/CellCheck.cginc"


bool ChunkBoundaryCheck(uint2 pos)
{
    return pos.x>=0 && pos.x<_width && pos.y>=0 && pos.y<_height;
}

void MoveCell(uint x, uint y, uint dir)
{
    _chunkBuffer[(x+direction[dir].x) + (y+direction[dir].y) * _width].type = _chunkBuffer[x + y * _width].type;
    _chunkBuffer[x + y * _width].type = 0;
}

void SetCell(uint2 pos, uint type)
{
    if(ChunkBoundaryCheck(pos))
    {
        _chunkBuffer[pos.x + pos.y * _width].type = type;
    }
}

void SandBehavior(uint2 id)
{
    uint flatIndex = id.x + (id.y * _width);

    bool check_down_left = CheckCell(id.x, id.y, DOWN_LEFT);
    bool check_down = CheckCell(id.x, id.y, DOWN);
    bool check_down_right = CheckCell(id.x, id.y, DOWN_RIGHT);

    // if below this cell is empty, then move down
    if(!check_down)
    {
        MoveCell(id.x, id.y, DOWN);
    }
    else
    {
        if(!check_down_left && !check_down_right)
        {
            if(_evenIteration)
                MoveCell(id.x, id.y, DOWN_LEFT);
            else
                MoveCell(id.x, id.y, DOWN_RIGHT);
        }
        else if(!check_down_left && check_down_right)
        {
            MoveCell(id.x, id.y, DOWN_LEFT);
        }
        else if(check_down_left && !check_down_right)
        {
            MoveCell(id.x, id.y, DOWN_RIGHT);
        }
    }

    _chunkBuffer[6].type = 666;
}

void SandEmmiterBehaviour(uint2 id)
{
    // if below this cell is empty, then make below type 1
    if(!CheckCell(id.x, id.y-1, 1))
    {
        _chunkBuffer[(id.x) + (id.y-1) * _width].type = 1;
    }
}

[numthreads(8, 8, 1)]
void ClearData (uint3 id : SV_DispatchThreadID)
{
    // Boundary check
    if(id.x >= _width || id.y >= _height)
        return;

    // Make flatIdex with y up to down
    uint flatIndex = id.x + (id.y * _width);
    
    _chunkBuffer[flatIndex].isActive = 0;
    _chunkBuffer[flatIndex].isMoved = 0;
    _chunkBuffer[flatIndex].value = 0;
    _chunkBuffer[flatIndex].type = 0;
}

[numthreads(8,8,1)]
void CopyInput (uint3 id : SV_DispatchThreadID)
{
    // Boundary check
    if(!ChunkBoundaryCheck(id.xy))
        return;

    uint inFlatIndex = id.x + (id.y * _inputWidth);
    uint outFlatIndex = id.x + (id.y * _width);
    _chunkBuffer[outFlatIndex].type = _inputBuffer[inFlatIndex];
    _chunkBuffer[outFlatIndex].isActive = 1;
    _chunkBuffer[outFlatIndex].isMoved = 0;

    // Debug
    if(_debug) 
        _chunkBuffer[0].type = 666;
}

[numthreads(8,8,1)]
void OneStep (uint3 id : SV_DispatchThreadID)
{
    if(!ChunkBoundaryCheck(id.xy))
        return;

    uint flatIndex = id.x + (id.y * _width);

    switch(_chunkBuffer[flatIndex].type)
    {
        case 1:
            SandBehavior(uint2(id.x, id.y));
            break;
        case 10:
            SandEmmiterBehaviour(id.xy);
            break;
    }

    _chunkBuffer[1].type = 666;
}

[numthreads(8,8,1)]
void DrawChunk (uint3 id : SV_DispatchThreadID)
{
    if(!ChunkBoundaryCheck(id.xy))
        return;

    uint flatIndex = id.x + (id.y * _width);

    _chunkBuffer[2].type = 666;
    switch(_chunkBuffer[flatIndex].type)
    {
        case 0:
            _mainBuffer[id.xy] = float4(0, 0, 0, 1);
            break;
        case 1:
            _mainBuffer[id.xy] = float4(.5, .5, .5, 1);
            break;
        case 10:
            _mainBuffer[id.xy] = float4(0, 1, 0, 1);
            break;
        case 666:
            _mainBuffer[id.xy] = float4(1, 0, 0, 1);
            break;
    }
    
}

[numthreads(1,1,1)]
void InsertCells (uint3 id : SV_DispatchThreadID)
{
    for(uint i=0; i<_inputLength; i++)
    {
        if(ChunkBoundaryCheck(uint2(_inputCellsBuffer[i].position.x, _inputCellsBuffer[i].position.y)))
        {
            _chunkBuffer[(_inputCellsBuffer[i].position.x) + (_inputCellsBuffer[i].position.y * _width)].type = _inputCellsBuffer[i].type;
            _chunkBuffer[(_inputCellsBuffer[i].position.x) + (_inputCellsBuffer[i].position.y * _width)].isActive = 1;
            _chunkBuffer[(_inputCellsBuffer[i].position.x) + (_inputCellsBuffer[i].position.y * _width)].isMoved = 0;
        }
    }
}

